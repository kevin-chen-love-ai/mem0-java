package com.mem0.embedding;

import java.util.List;
import java.util.concurrent.CompletableFuture;

/**
 * 嵌入提供者接口
 * Embedding provider interface for generating vector embeddings from text
 * 
 * <p>此接口定义了嵌入向量生成服务的核心功能，支持单个和批量文本嵌入向量生成。 / 
 * This interface defines core functionality for embedding vector generation services, supporting both single and batch text embedding generation.</p>
 * 
 * <p>嵌入提供者可以是 / Embedding providers can be:</p>
 * <ul>
 *   <li>OpenAI Embeddings API</li>
 *   <li>Hugging Face Transformers</li>
 *   <li>Sentence Transformers</li>
 *   <li>Google Universal Sentence Encoder</li>
 *   <li>本地模型服务 / Local model services</li>
 * </ul>
 * 
 * <p>使用示例 / Usage example:</p>
 * <pre>{@code
 * EmbeddingProvider provider = new OpenAIEmbeddingProvider(apiKey);
 * 
 * // 单个文本嵌入
 * List<Float> embedding = provider.embed("记忆内容").join();
 * 
 * // 批量文本嵌入
 * List<String> texts = Arrays.asList("文本1", "文本2", "文本3");
 * List<List<Float>> embeddings = provider.embedBatch(texts).join();
 * 
 * // 获取向量维度
 * int dimension = provider.getDimension();
 * }</pre>
 * 
 * @author kevin.chen
 * @version 1.0
 * @since 1.0
 */
public interface EmbeddingProvider {
    
    /**
     * 为单个文本生成嵌入向量
     * Generates embedding vector for a single text
     * 
     * <p>将输入文本转换为密集的向量表示，用于语义相似性计算和搜索。 / 
     * Converts input text into a dense vector representation for semantic similarity calculation and search.</p>
     * 
     * @param text 要嵌入的文本内容，不能为null或空字符串 / Text content to embed, cannot be null or empty string
     * @return CompletableFuture<List<Float>>，返回嵌入向量，维度由提供者决定 / CompletableFuture<List<Float>>, returns embedding vector with dimension determined by provider
     * 
     * @throws IllegalArgumentException 如果text为null或空字符串 / if text is null or empty string
     * @throws RuntimeException 如果嵌入生成失败 / if embedding generation fails
     */
    CompletableFuture<List<Float>> embed(String text);
    
    /**
     * 为多个文本批量生成嵌入向量
     * Generates embedding vectors for multiple texts in batch
     * 
     * <p>批量处理可以显著提高性能，特别是在使用API服务时能减少网络开销。 / 
     * Batch processing can significantly improve performance, especially when using API services by reducing network overhead.</p>
     * 
     * @param texts 要嵌入的文本列表，不能为null或包含null元素 / List of texts to embed, cannot be null or contain null elements
     * @return CompletableFuture<List<List<Float>>>，返回嵌入向量列表，顺序与输入一致 / CompletableFuture<List<List<Float>>>, returns list of embedding vectors in same order as input
     * 
     * @throws IllegalArgumentException 如果texts为null、空列表或包含null/空字符串 / if texts is null, empty list, or contains null/empty strings
     * @throws RuntimeException 如果批量嵌入生成失败 / if batch embedding generation fails
     */
    CompletableFuture<List<List<Float>>> embedBatch(List<String> texts);
    
    /**
     * 获取嵌入向量的维度
     * Gets the dimension of embedding vectors
     * 
     * <p>返回由此提供者生成的嵌入向量的维度大小。所有由同一提供者生成的向量都具有相同的维度。 / 
     * Returns the dimension size of embedding vectors generated by this provider. All vectors generated by the same provider have the same dimension.</p>
     * 
     * @return 嵌入向量的维度，必须大于0 / Dimension of embedding vectors, must be greater than 0
     */
    int getDimension();
    
    /**
     * 获取嵌入向量维度（向后兼容的别名方法）
     * Gets embedding vector dimension (alias method for backward compatibility)
     * 
     * <p>此方法与getDimension()功能相同，仅为保持向后兼容性。 / 
     * This method has the same functionality as getDimension(), provided only for backward compatibility.</p>
     * 
     * @return 嵌入向量的维度 / Dimension of embedding vectors
     * @deprecated 使用 {@link #getDimension()} 替代 / Use {@link #getDimension()} instead
     */
    @Deprecated
    default int getDimensions() {
        return getDimension();
    }
    
    /**
     * 获取提供者名称
     * Gets the provider name
     * 
     * <p>返回标识此嵌入提供者的名称，用于日志记录、配置和调试。 / 
     * Returns the name identifying this embedding provider, used for logging, configuration, and debugging.</p>
     * 
     * @return 提供者名称，不能为null或空字符串 / Provider name, cannot be null or empty string
     */
    String getProviderName();
    
    /**
     * 检查提供者是否处于健康状态
     * Checks if the provider is in a healthy state
     * 
     * <p>健康检查包括但不限于 / Health check includes but is not limited to:</p>
     * <ul>
 *   <li>API连接状态 / API connection status</li>
 *   <li>认证有效性 / Authentication validity</li>
 *   <li>服务可用性 / Service availability</li>
 *   <li>配额限制 / Rate limit status</li>
 * </ul>
     * 
     * <p>建议在使用提供者之前调用此方法进行检查。 / 
     * It's recommended to call this method to check before using the provider.</p>
     * 
     * @return true表示健康状态，false表示存在问题 / true if healthy, false if there are issues
     */
    boolean isHealthy();
    
    /**
     * 关闭提供者并释放资源
     * Closes the provider and releases resources
     * 
     * <p>关闭所有连接，释放线程池、内存和其他系统资源。调用此方法后，提供者将不可用。 / 
     * Closes all connections, releases thread pools, memory, and other system resources. Provider becomes unusable after this call.</p>
     * 
     * <p>此方法应该是幂等的，多次调用不应该产生副作用。 / 
     * This method should be idempotent, multiple calls should not cause side effects.</p>
     * 
     * @throws RuntimeException 如枟关闭过程中发生错误 / if an error occurs during closing
     */
    void close();
}